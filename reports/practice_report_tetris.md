# Отчёт по созданию игры «Тетрис» на языке С с использованием SDL2

## Почему я решила сделать «Тетрис»

Я выбрала задание «Тетрис» в качестве индивидуального проекта в рамках проектной практики, потому что он идеально подходит для изучения базовых принципов создания оконных приложений и работы с графическим интерфейсом. «Тетрис» — это классическая игра с простыми правилами, но интересной логикой, которая помогает понять основы:  
- работы с графикой (отображение фигур и поля),  
- взаимодействия с пользователем (управление клавишами),  
- работы с памятью и структурой данных.  
Кроме того, я хотела освоить **SDL2**, библиотеку для рендеринга графики, которая используется в индустрии для создания игр и визуализаций.

---

## Исходный код

Весь проект написан на **С** с использованием **SDL2**.  
Привожу весь код, а ниже подробно объясняю каждую часть.
```c
#define SDL_MAIN_HANDLED
#include <SDL2/SDL.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define WIDTH 10
#define HEIGHT 20
#define BLOCK_SIZE 30

int field[HEIGHT][WIDTH] = {0};
int currentX = 0, currentY = 0;
int currentBlock = 0, rotation = 0;
int gameOver = 0;

int blocks[7][4][4][4] = { ... };

int canMove(int dx, int dy, int nextRotation);
void newBlock() { ... }
int canMove(int dx, int dy, int nextRotation) { ... }
void placeBlock() { ... }
void clearLines() { ... }
void resetGame() { ... }
void draw(SDL_Renderer* renderer, SDL_Texture* gameOverTexture) { ... }

int main() { ... }
```
### Подробные объяснения
Подключение библиотек
``` c 
#define SDL_MAIN_HANDLED
#include <SDL2/SDL.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
```
- #define SDL_MAIN_HANDLED — нужен, чтобы SDL не переопределял main().
- SDL2/SDL.h — библиотека для окон и графики.
- stdio.h, stdlib.h — стандартные функции ввода-вывода и работы с памятью.
- time.h — для генерации случайных чисел.

--- 

``` c
#define WIDTH 10
#define HEIGHT 20
#define BLOCK_SIZE 30
```
Определяет размер игрового поля: 
- 10 (ширина) × 20 (высота).
- Каждый блок (квадрат) — 30 пикселей.

---
Глобальные переменные
``` c 
int field[HEIGHT][WIDTH] = {0};
int currentX = 0, currentY = 0;
int currentBlock = 0, rotation = 0;
int gameOver = 0;
```
field — массив для хранения состояния поля (0 — пусто, 1 — занято).
currentX, currentY — координаты текущей фигуры.
currentBlock — тип фигуры (от 0 до 6).
rotation — текущий поворот фигуры.
gameOver — флаг, показывающий конец игры.

---
Массив с фигурами
``` c
int blocks[7][4][4][4] = { ... };
```
7 фигур.
Для каждой — 4 поворота.
Каждая фигура хранится как 4×4 матрица.

--- 

Функция создания новой фигуры
``` c
void newBlock() {
    currentBlock = rand() % 7;
    rotation = 0;
    currentX = WIDTH / 2 - 2;
    currentY = 0;
    if (!canMove(0, 0, rotation)) {
        gameOver = 1;
    }
}
```
Выбираем случайную фигуру.
Ставим её в центр.
Если новая фигура не помещается — конец игры.

---
Проверка возможности движения
``` c
int canMove(int dx, int dy, int nextRotation) { ... }
``` 
Перебираем все 4×4 клетки фигуры.
Смотрим, не выходит ли она за границы.
Проверяем, нет ли пересечения с уже занятыми клетками поля.

--- 
Размещение фигуры на поле
``` c
void placeBlock() { ... }
```
Копируем «1» из фигуры в field.

---
Очистка линий
``` c
void clearLines() {
    for (int y = HEIGHT - 1; y >= 0; y--) {
        int full = 1;
        for (int x = 0; x < WIDTH; x++)
            if (field[y][x] == 0) {
                full = 0;
                break;
            }
        if (full) {
            for (int ny = y; ny > 0; ny--)
                for (int x = 0; x < WIDTH; x++)
                    field[ny][x] = field[ny-1][x];
            for (int x = 0; x < WIDTH; x++)
                field[0][x] = 0;
            y++;
        }
    }
}
```
Ищем полные линии.
Если линия полная — убираем её.
Сдвигаем все сверху вниз.

---
Сброс игры
``` c
void resetGame() {
    for (int y = 0; y < HEIGHT; y++)
        for (int x = 0; x < WIDTH; x++)
            field[y][x] = 0;
    gameOver = 0;
    newBlock();
}
```
Очищаем поле.
Снимаем флаг конца игры.
Создаём новую фигуру.

---
Отрисовка игры
``` c
void draw(SDL_Renderer* renderer, SDL_Texture* gameOverTexture) { ... }
```
Очищаем экран.
Рисуем уже установленные блоки.
Рисуем текущую падающую фигуру.
Если игра окончена — рисуем красный экран с заглушкой «Game Over».

---
Главный цикл игры
``` c 
int main() { ... }
```
SDL_Init — инициализация SDL2.
Создаём окно и рендерер.
Основной цикл:
Считываем события (нажатия клавиш).
Каждые 500 мс — фигура падает вниз.
Отрисовываем игру.
При закрытии окна — удаляем ресурсы.

---
# Итог
Вышел был представлено поэтапное руководство написания своего собственного тетриса. От человека к человеку программа будет изменяться, и видоизменять свои функции. Здесь представлен основной скилет. 
